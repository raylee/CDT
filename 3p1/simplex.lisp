;; 3simplex
;; (type tmlo tmhi (p0 p1 p2 p3))
;; type = 0,1,2,3,4 tm[lo|hi] = [lo|hi] spatial time slice pj = points

;; 4simplex
;; (type tmlo tmhi (p0 p1 p2 p3 p4) (n0 n1 n2 n3 n4) (t0 t1 t2 t3 t4))
;; type = 1,2,3,4 tm[lo|hi] - [lo|hi] spatial time slice
;; tj = id of the 2sx that does not have pj
;; nj = id of the 3sx that does not have pj

(defun make-3simplex (type tmlo tmhi p0 p1 p2 p3)
  "makes and returns the id of the 3-simplex with the specified data. If a 3-simplex with points 
p0 p1 p2 p3 already exists, the id of that simplex is returned"
  (let* ((3sx (list type tmlo tmhi (list p0 p1 p2 p3)))
	 (3sxid (gethash 3sx *3SIMPLEX->ID*)))
    (unless 3sxid
      (setf 3sxid (next-3simplex-id))
      (setf (gethash 3sx *3SIMPLEX->ID*) 3sxid)
      (setf (gethash 3sxid *ID->3SIMPLEX*) 3sx))
    3sxid))
(defmacro get-3simplex (sxid)
  `(gethash ,sxid *ID->3SIMPLEX*))

;; the 3-simplex abstraction
(defmacro 3sx-type (sx)
  `(first ,sx))
(defmacro 3sx-tmlo (sx)
  `(second ,sx))
(defmacro 3sx-tmhi (sx)
  `(third ,sx))
(defmacro 3sx-points (sx)
  `(fourth ,sx))
(defmacro 3sx-lopts (sx)
  `(subseq (3sx-points ,sx) 0 (3sx-type ,sx)))
(defmacro 3sx-hipts (sx)
  `(subseq (3sx-points ,sx) (3sx-type ,sx)))

(defmacro remove-3simplex (3sxid)
  `(let ((3sx (gethash ,3sxid *ID->3SIMPLEX*)))
     (remhash ,3sxid *ID->3SIMPLEX*)
     (remhash 3sx *3SIMPLEX->ID*)))
(defun remove-3simplices (3sxids)
  (dolist (3sxid 3sxids)
    (let ((3sx (gethash 3sxid *ID->3SIMPLEX*)))
      (remhash 3sxid *ID->3SIMPLEX*)
      (remhash 3sx *3SIMPLEX->ID*))))
(defun show-3simplex->id-store ()
  (maphash #'(lambda (3sx 3sxid) (format t "~A [~A]~%" 3sx 3sxid)) *3SIMPLEX->ID*))
(defun show-id->3simplex-store ()
  (maphash #'(lambda (3sxid 3sx) (format t "[~A] ~A~%" 3sxid 3sx)) *ID->3SIMPLEX*))


(defun make-4simplex (type tmlo tmhi p0 p1 p2 p3 p4)
  (let ((t0type nil) (t1type nil) (t2type nil) (t3type nil) (t4type nil) (sx4id (next-4simplex-id)))
    (ecase type
      (1 (setf t0type 0) (setf t1type 1) (setf t2type 1)(setf t3type 1) (setf t4type 1))
      (2 (setf t0type 1) (setf t1type 1) (setf t2type 2)(setf t3type 2) (setf t4type 2))
      (3 (setf t0type 2) (setf t1type 2) (setf t2type 2)(setf t3type 3) (setf t4type 3))
      (4 (setf t0type 3) (setf t1type 3) (setf t2type 3)(setf t3type 3) (setf t4type 4)))
    (setf (gethash sx4id *ID->4SIMPLEX*)
	  (list type tmlo tmhi
		(list p0 p1 p2 p3 p4)
		(list 0 0 0 0 0)
		(list (make-3simplex t0type tmlo tmhi p1 p2 p3 p4)
		      (make-3simplex t1type tmlo tmhi p0 p2 p3 p4)
		      (make-3simplex t2type tmlo tmhi p0 p1 p3 p4)
		      (make-3simplex t3type tmlo tmhi p0 p1 p2 p4)
		      (make-3simplex t4type tmlo tmhi p0 p1 p2 p3))))
    sx4id))

;; same as make-4simplex except the points are packed in a list called pts
(defun make-4simplex-v2 (type tmlo tmhi pts)
  (let ((t0type nil) (t1type nil) (t2type nil) (t3type nil) (t4type nil) (sx4id (next-4simplex-id)))
    (ecase type
      (1 (setf t0type 0) (setf t1type 1) (setf t2type 1)(setf t3type 1) (setf t4type 1))
      (2 (setf t0type 1) (setf t1type 1) (setf t2type 2)(setf t3type 2) (setf t4type 2))
      (3 (setf t0type 2) (setf t1type 2) (setf t2type 2)(setf t3type 3) (setf t4type 3))
      (4 (setf t0type 3) (setf t1type 3) (setf t2type 3)(setf t3type 3) (setf t4type 4)))
    (setf (gethash sx4id *ID->4SIMPLEX*)
	  (list type tmlo tmhi
		(copy-list pts)
		(list 0 0 0 0 0)
		(list (make-3simplex t0type tmlo tmhi (nth 1 pts) (nth 2 pts) (nth 3 pts) (nth 4 pts))
		      (make-3simplex t1type tmlo tmhi (nth 0 pts) (nth 2 pts) (nth 3 pts) (nth 4 pts))
		      (make-3simplex t2type tmlo tmhi (nth 0 pts) (nth 1 pts) (nth 3 pts) (nth 4 pts))
		      (make-3simplex t3type tmlo tmhi (nth 0 pts) (nth 1 pts) (nth 2 pts) (nth 4 pts))
		      (make-3simplex t4type tmlo tmhi (nth 0 pts) (nth 1 pts) (nth 2 pts) (nth 3 pts)))))
    sx4id))

;; same as make-4simplex except handles some point adjustments for the periodic boundary conditions
;; called only during initialization.
(defun make-4simplex-v3 (type tmlo tmhitmp p0tmp p1tmp p2tmp p3tmp p4tmp)
  (let ((t0type nil) (t1type nil) (t2type nil) (t3type nil) (t4type nil) (sx4id (next-4simplex-id))
	(p0 p0tmp) (p1 p1tmp) (p2 p2tmp) (p3 p3tmp) (p4 p4tmp) (tmhi tmhitmp))
    (when (and (string= BCTYPE "PERIODIC") (= NUM-T tmhitmp))
      (setf tmhi 0)
      (cond ((= 1 type)
	     (decf p1 (* 5 NUM-T)) (decf p2 (* 5 NUM-T)) (decf p3 (* 5 NUM-T)) (decf p4 (* 5 NUM-T)))
	    ((= 2 type)
	     (decf p2 (* 5 NUM-T)) (decf p3 (* 5 NUM-T)) (decf p4 (* 5 NUM-T)))
	    ((= 3 type)
	     (decf p3 (* 5 NUM-T)) (decf p4 (* 5 NUM-T)))
	    ((= 4 type)
	     (decf p4 (* 5 NUM-T)))))
    (ecase type
      (1 (setf t0type 0) (setf t1type 1) (setf t2type 1)(setf t3type 1) (setf t4type 1))
      (2 (setf t0type 1) (setf t1type 1) (setf t2type 2)(setf t3type 2) (setf t4type 2))
      (3 (setf t0type 2) (setf t1type 2) (setf t2type 2)(setf t3type 3) (setf t4type 3))
      (4 (setf t0type 3) (setf t1type 3) (setf t2type 3)(setf t3type 3) (setf t4type 4)))
    (setf (gethash sx4id *ID->4SIMPLEX*)
	  (list type tmlo tmhi
		(list p0 p1 p2 p3 p4)
		(list 0 0 0 0 0)
		(list (make-3simplex t0type tmlo tmhi p1 p2 p3 p4)
		      (make-3simplex t1type tmlo tmhi p0 p2 p3 p4)
		      (make-3simplex t2type tmlo tmhi p0 p1 p3 p4)
		      (make-3simplex t3type tmlo tmhi p0 p1 p2 p4)
		      (make-3simplex t4type tmlo tmhi p0 p1 p2 p3))))
    sx4id))

;; the 4-simplex abstraction
(defmacro 4sx-type (sx) `(first ,sx))
(defmacro 4sx-tmlo (sx) `(second ,sx))
(defmacro 4sx-tmhi (sx) `(third ,sx))
(defmacro 4sx-points (sx) `(fourth ,sx))
(defmacro 4sx-sx4ids (sx) `(fifth ,sx))
(defmacro 4sx-sx3ids (sx) `(sixth ,sx))
(defmacro 4sx-lopts (sx) `(subseq (4sx-points ,sx) 0 (4sx-type ,sx)))
(defmacro 4sx-hipts (sx) `(subseq (4sx-points ,sx) (4sx-type ,sx)))

(defmacro get-4simplex (sxid)
  `(gethash ,sxid *ID->4SIMPLEX*))
(defun remove-4simplex (4sxid)
  (let ((4sx (gethash 4sxid *ID->4SIMPLEX*)))
    (dolist (nid (4sx-sx3ids 4sx))
      (unless (= 0 nid)
	(substitute 0 4sxid (4sx-sx4ids (get-4simplex nid))))))
  (remhash 4sxid *ID->4SIMPLEX*))
(defun remove-4simplices (4sxids)
  (dolist (4sxid 4sxids)
    (let ((4sx (gethash 4sxid *ID->4SIMPLEX*)))
      (dolist (nid (4sx-sx3ids 4sx))
	(unless (= 0 nid)
	  (substitute 0 4sxid (4sx-sx4ids (get-4simplex nid))))))
    (remhash 4sxid *ID->4SIMPLEX*)))
(defun show-id->4simplex-store ()
  (maphash #'(lambda (4sxid 4sx) (format t "[~A] ~A~%" 4sxid 4sx)) *ID->4SIMPLEX*))

(defmacro nth-point (sx n)
  `(nth ,n (4sx-points ,sx)))

(defun connect-4simplices (sx1id sx2id)
  (let ((sx1 nil) (sx2 nil))
    (when (and (setf sx1 (get-4simplex sx1id)) (setf sx2 (get-4simplex sx2id)))
      (let ((3sxlinkid (intersection (4sx-sx3ids sx1) (4sx-sx3ids sx2))))
	(when (= 1 (length 3sxlinkid))
	  (let ((pos1 (position (first 3sxlinkid) (4sx-sx3ids sx1)))
		(pos2 (position (first 3sxlinkid) (4sx-sx3ids sx2))))
	    (setf (nth pos1 (4sx-sx4ids sx1)) sx2id) (setf (nth pos2 (4sx-sx4ids sx2)) sx1id)))))))

(defun connect-4simplices-within-list (sx1ids)
  (for (n 0 (1- (length sx1ids)))
       (for (m (1+ n) (1- (length sx1ids)))
	    (connect-4simplices (nth n sx1ids) (nth m sx1ids)))))

(defun connect-4simplices-across-lists (sx1ids sx2ids)
  (dolist (sx1id sx1ids)
    (dolist (sx2id sx2ids)
      (connect-4simplices sx1id sx2id))))

(defmacro 4simplices-connected? (sxid1 sxid2)
  `(let ((foosx1 nil) (foosx2 nil))
     (and (setf foosx1 (get-4simplex ,sxid1)) (setf foosx2 (get-4simplex ,sxid2))
	  (find ,sxid1 (4sx-sx4ids foosx2)) (find ,sxid2 (4sx-sx4ids foosx1)))))

(defun 4simplices-connected?-d (sxid1 sxid2)
  (let ((sx1 nil) (sx2 nil))
    (if (and (setf sx1 (get-4simplex sxid1)) (setf sx2 (get-4simplex sxid2))
	  (find sxid1 (4sx-sx4ids sx2)) (find sxid2 (4sx-sx4ids sx1)))
	(progn
	  (format t "~A and ~A are connected~%" sxid1 sxid2)
	  (return-from 4simplices-connected?-d T))
	(format t "~A and ~A are NOT connected~%" sxid1 sxid2))))

(defun get-simplices-in-sandwich (tlo thi)
  (let ((sxids '()))
    (maphash #'(lambda (id sx)
		 (when (and (= (4sx-tmlo sx) (mod tlo NUM-T)) 
			    (= (4sx-tmhi sx) (mod thi NUM-T)))
		   (push id sxids)))
	     *ID->4SIMPLEX*)
    sxids))

(defun get-simplices-in-sandwich-of-type (tlo thi typ)
  (let ((sxids '()))
    (maphash #'(lambda (id sx)
		 (when (and (= (4sx-tmlo sx) (mod tlo NUM-T)) 
			    (= (4sx-tmhi sx) (mod thi NUM-T))
			    (= (4sx-type sx) typ))
		   (push id sxids)))
	     *ID->4SIMPLEX*)
    sxids))

(defun get-simplices-of-type (typ)
  (let ((sxids '()))
    (maphash #'(lambda (id sx)
		 (if (= (4sx-type sx) typ)
		     (push id sxids)))
	     *ID->4SIMPLEX*)
    sxids))

(defun count-simplices-of-type (typ)
  (let ((count 0))
    (maphash #'(lambda (id sx)
		 (declare (ignore id))
		 (if (= (4sx-type sx) typ)
		     (incf count)))
	     *ID->4SIMPLEX*)
    count))

(defun count-simplices-in-sandwich (tlo thi)
  (let ((count 0))
    (maphash #'(lambda (id sx)
		 (declare (ignore id))
		 (when (and (= (4sx-tmlo sx) (mod tlo NUM-T)) 
			    (= (4sx-tmhi sx) (mod thi NUM-T)))
		     (incf count)))
	     *ID->4SIMPLEX*)
    count))

(defun count-simplices-of-all-types ()
  (let ((1count 0) (2count 0) (3count 0) (4count 0))
    (maphash #'(lambda (id sx)
		 (declare (ignore id))
		 (ecase (4sx-type sx)
		   (1 (incf 1count))
		   (2 (incf 2count))
		   (3 (incf 3count))
		   (4 (incf 4count))))
	     *ID->4SIMPLEX*)
    (list 1count 2count 3count 4count (+ 1count 2count 3count 4count))))

(defun connect-simplices-in-sandwich (tlo thi)
  (connect-4simplices-within-list (get-simplices-in-sandwich tlo thi)))

(defun connect-simplices-in-adjacent-sandwiches (tl tm th)
  (connect-4simplices-across-lists 
   (get-simplices-in-sandwich-of-type tl tm 1)
   (get-simplices-in-sandwich-of-type tm th 4)))

(defun check-14-and-41 (tlo thi)
  (let ((14ids (get-simplices-in-sandwich-of-type tlo thi 1))
	(41ids (get-simplices-in-sandwich-of-type tlo thi 4))
	(problem-ids '()))
    (dolist (s14 14ids)
      (dolist (d14 14ids)
	(when (and (/= s14 d14) (set-equal? (subseq (4sx-points (get-4simplex s14)) 1)
					    (subseq (4sx-points (get-4simplex d14)) 1)))
	  (push (list s14 d14) problem-ids))))
    (dolist (s41 41ids)
      (dolist (d41 41ids)
	(when (and (/= s41 d41) (set-equal? (subseq (4sx-points (get-4simplex s41)) 0 4)
					    (subseq (4sx-points (get-4simplex d41)) 0 4)))
	  (push (list s41 d41) problem-ids))))
    problem-ids))

(defun check-all-slices-for-problem-simplices ()
  (for (ts 0 (- NUM-T 1))
       (format t "slice ~A has ~A problem simplices~%" ts (check-14-and-41 ts (1+ ts)))
       (finish-output)))

(defun check-all-slices-for-simplices-with-missing-neighbors ()
  (let ((problem-ids '()))
    (maphash #'(lambda (id sx)
		 (for (n 0 4)
		   (if (= 0 (nth n (4sx-sx4ids sx)))
		       (push id problem-ids))))
	     *ID->4SIMPLEX*)
    problem-ids))

(defmacro link-id (sxid1 sxid2)
  `(let ((sx1 nil) (sx2 nil) (link nil))
     (if (and (setf sx1 (get-4simplex ,sxid1)) 
	      (setf sx2 (get-4simplex ,sxid2))
	      (setf link (intersection (4sx-sx3ids sx2) (4sx-sx3ids sx1))))
	 (first link)
	 0)))

;; if the 4simplices are connected returns (id pos1 pos2) where id is the id of the linking 3-simplex
;; pos1 is the position of this linkid in the sx3ids list of the first simplex
;; pos2 is the position of this linkid in the sx3ids list of the second simplex
;; if the two simplices are not connected, returns (0 -1 -1)
(defmacro link-id-and-positions (sxid1 sxid2)
  `(let ((sx1 nil) (sx2 nil) (link nil))
     (if (and (setf sx1 (get-4simplex ,sxid1))
	      (setf sx2 (get-4simplex ,sxid2))
	      (setf link (intersection (4sx-sx3ids sx1) (4sx-sx3ids sx2))))
	 (list (first link) 
	       (position (first link) (4sx-sx3ids sx1)) 
	       (position (first link) (4sx-sx3ids sx2)))
	 (list 0 -1 -1))))
  
(defun neighbors-of-type (sx type)
  (let ((nbors nil)
	(nsx nil)
	(nids (4sx-sx4ids sx)))
    (for (n 0 4)
      (when (and (setf nsx (get-4simplex (nth n nids))) (= type (4sx-type nsx)))
	(pushnew (nth n nids) nbors)))
    nbors))

;; <<<<<<<<<<<<<<<<< done till here >>>>>>>>>>>>>>>>>>>>>>>>>
#|
(defun save-spacetime-to-file (outfile)
  (format outfile "~A ~A ~A ~A ~A ~A ~A ~A ~A ~A ~A ~A ~A ~A ~A~%" 
	  BCTYPE STOPOLOGY NUM-T N-INIT *LAST-USED-POINT* 
	  N0 N1-SL N1-TL N2-SL N2-TL N3-TL-31 N3-TL-22 eps k0 k3)
  (maphash #'(lambda (k v)
	       (declare (ignore k))
	       (format outfile "~A ~A ~A ~A ~A ~A ~A~%" 
		       (3sx-type v) (3sx-tmlo v) (3sx-tmhi v)
		       (nth-point v 0) (nth-point v 1) (nth-point v 2) (nth-point v 3)))
	   *ID->3SIMPLEX*))

(defun parse-parameters-line (line)
  (with-input-from-string (s line)
    (let ((data (loop
		   :for num := (read s nil nil)
		   :while num
		   :collect num)))
      (setf BCTYPE (nth 0 data))
      (setf STOPOLOGY (nth 1 data))
      (setf NUM-T (nth 2 data))
      (setf N-INIT (nth 3 data))
      (setf *LAST-USED-POINT* (nth 4 data))
      (setf N0 (nth 5 data))
      (setf N1-SL (nth 6 data))
      (setf N1-TL (nth 7 data))
      (setf N2-SL (nth 8 data))
      (setf N2-TL (nth 9 data))
      (setf N3-TL-31 (nth 10 data))
      (setf N3-TL-22 (nth 11 data))
      (setf eps (nth 12 data))
      (setf k0 (nth 13 data))
      (setf k3 (nth 14 data)))))

(defun parse-simplex-data-line (line)
  (with-input-from-string (s line)
    (let ((data (loop
		   :for num := (read s nil nil)
		   :while num
		   :collect num)))
      (make-3simplex (first data) (second data) (third data) 
		    (fourth data) (fifth data) (sixth data) (seventh data)))))

(defun load-spacetime-from-file (infile)
  (parse-parameters-line (read-line infile nil))
  (loop for line = (read-line infile nil)
     while line do (parse-simplex-data-line line))
  (for (ts 0 (- NUM-T 1))
       (connect-simplices-in-sandwich ts (1+ ts) )
       (connect-simplices-in-adjacent-sandwiches ts (+ ts 1) (+ ts 2)))
  (when (and (string= STOPOLOGY "S2") (string= BCTYPE "PERIODIC"))
    (setf (symbol-function 'action) #'action-S1xS2)))

|#