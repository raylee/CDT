Program and Module List

Authors: Jonah Miller (jonah.maxwell.miller@gmail.com)
	 Rajesh Kommu
	 Christian Anderson
	 David Kamensky

Note that ~ refers to the home directory for this program: 
     CDT/2p1-fixed-boundaries


PYTHON PROGRAMS (all live in ~/data_analysis_scripts)
;+-----------------------------------------------------------------------------+
average_ensemble.py -- function call: 
		           ./average_ensemble.py /path/to/ensemble/*.3sx2p1

                       takes average number of space-like triangles per time 
		       slice and plots. Fits this to the equation for de Sitter
		       space with a stalk. Error bars are standard deviation
		       of spactial extent, NOT error of fit.



visualize_spacetime.py -- function call: 
		       ./visualize_spacetime.py /path/to/spacetime/file.3sx2p1

		       makes a plot of the spatial extent of a single spacetime
		       as a function of proper time. Dependency of 
		       average_ensemble.py



invert_time.py -- function_call:
			./invert_time.py /path/to/spacetime/file.3sx2p1

			Takes a *.3sx2p1 file and reverses the time coordinate.
			so that a (1,3) simplex with t_low = 0 and t_high = 1
			becomes a (3,1) simplex with t_low = 63 and t_high = 64.
			Useful mostly for debugging.



make_boundary_conditions.py -- function call:
		    ./make_boundary_conditions.py t_low t_high filename.3sx2p1

		    Takes a *.3sx2p1 file and a pair of indices as input. It 
		    generates a pair of text files that can be used by the 
		    fixed boundary code as input for fixed boundaries using the
		    time slices at the chosen indices t_low and t_high 
		    in the simulation that generated filename as the boundaries.



map_phase_space_parallelized.py -- function call: 
			map_phase_space_parallelized.py >> logfilename.log
			
			Runs a simulation over a range of k0 and k3
			values.  The goal is to find at which values
			of k0 and k3 the simulation is stable. Uses a
			module written in lisp for the simulation to
			facilitate taking data on volume change and
			sending it to an output file. The output file
			can be analyzed with k3_of_k0.py and
			visualized with plot_phasemap.py, which are
			described below.

			This approach is different from the one taken
			by Christian in the HL code, where the
			probability of a move being topologically
			acceptable is approximately the same from
			simulation to simulation. Christian solves for
			the coupling constant values that give stable
			volume, whereas I just do a guess and check
			method. The reason is that with fixed
			boundaries, the probability ratios change
			depending on the boundary conditions. Brute
			force was the only completely general method I
			could think of.

			To make the mapping algorithm faster, each
			simulation with set k0 and k3 can be run on a
			seperate CPU. The program takes care of this
			automatically.

			To change simulation parameters, open up te
			file. It should be easy to change which
			boundary files are used, the number of time
			slices, and the target volume. Just change the
			variables in the code. The output is
			*.phasemap.



plot_phasemap.py -- Function call: ./plot_phasemap.py scf filename.phasemap

		    Makes a 3D plot of 3-volume of a CDT simulation as a
         	    function of coupling constants. in
		    2+1 dimensions. Also places the critical surface
		    on the plot for comparison.

		    The input file is a *.phasemap file generated by
		    map_phase_space_parallelized.py

		    Takes two command line arguments: a docstring and
		    a filename.  If the command string contains
		    certain letters, the function does more. Each
		    letter adds a functionality.

		    contains   function does
		    'f'        complete 3D plot of 3-volume(k0,k3)
		    's'        3D plot of 3-volume(k0,k3), but with 
		    	       values 0<=3-volume<=2.
                    'c'        Plots the critical surface and fits k3 as a 
		    	       function of k0. Outputs this information
			       to a file.
 
		    The filename is *.phasemap and is some phasemap.

		    Example calls:
		    ./plot_phasemap.py s T028_V030850.phasemap 
		    ./plot_phasemap.py scf T028_V030850.phasemap 


k3_of_k0.py -- function call:
	        ./k3_of_k0.py file.critical_surface_fit k0 k0

	       Takes *.critical_surface_fit data generated by
	       plot_phasemap.py (above) and constructs k3 as a
	       function of k0 using it. The function takes any number
	       of inputs. The first input is a fit file and the
	       remaining inputs are each a value of k0. The function
	       returns a value of k3.
;+-----------------------------------------------------------------------------+



SHELL SCRIPTS
;+-----------------------------------------------------------------------------+
Lives in ~/data_analysis_scripts/
extract_action.sh -- function call: ./extract_action.sh *.3sx2p1
 		     
		     Takes any number of spacetimes generated in an
		     ensemble and finds the average and standard
		     deviation of the Euclidean action obtained by
		     Wick rotation:
		     
		     S_euclidean = -i * S_wick-rotated.

		     The larger S_euclidean, the smaller the average
		     probability weight of a gven ensemble in the
		     partition function:

		     P(S) = e^{i* S_wick-rotated} = e^{-S_euclidean}.
		     
		     extract_action.sh relies on the
		     action_output.lisp module to the main CDT
		     program.

Lives in ~
start_cores.sh -- function call: ./start_cores.sh

	       	  Useful for running a number of CDT simulations at once. I
		  use it to build ensembles from a thermalized spacetime.
;+-----------------------------------------------------------------------------+



THE MAIN CDT PROGRAM:
;+-----------------------------------------------------------------------------+
cdt2p1.lisp -- cdt2p1.lisp is a top-level wrapper that exists mostly for
               convenience. It simply loads all the other modules required for
	       the CDT code to work. When one writes a script to run a 
	       simulation, one could replace 
	       (load "cdt2p1.lisp")
	       with
	       (load "../utilities.lisp")
	       (load "globals.lisp")
	       (load "tracking_vectors.lisp")
	       (load "action.lisp")
	       (load "reset_spacetime.lisp")
	       (load "generalized-hash-table-counting-functions.lisp")
	       (load "simplex.lisp")
	       (load "topological_checks.lisp")
	       (load "moves.lisp")
	       (load "ascii_plotting_tools.lisp")
	       (load "initialization.lisp")
	       (load "montecarlo.lisp")
	       (load "output.lisp").


~/../utilities.lisp -- utilities.lisp is one folder up in the main folder for 
		     all the code. It contains a number of functions and
                     macros that customize the lisp language and make it more 
		     useful. Nothing specific to the CDT code lives here, but 
		     many functions used in all versions of the CDT program 
		     are in this file. Many macros come from Paul Graham's
		     "On Lisp." Only dimension-independent utilities are in 
		     this file.


globals.lisp -- globals.lisp is a bit eclectic. It contains a bunch of 
	     	parameters and variables used by the rest of the simulation:
		1) hash tables that contain local geometric information, 
		   and some basic functions that work with them.
		2) Physical constants 
		3) Variables and functions that track and select ergotic moves
		   during a sweep and data-taking
		4) initialization data. This is only here to remove
		    annoying warning messages when the simulation starts up.
		    It is also more sanely contained in the initialization.lisp
		    file.
		5) The damping function used to control by how much we restrict
		   the simulation from changing the number of 3-simplices in
		   a spacetime.
		6) Miscellany. Honestly, the stuff that goes in globals.lisp
		   is the stuff I couldn't think of a good place to put.


tracking_vectors.lisp -- This file contains information for the f- and
		      	  b-vectors for the spacetime. These contain global
			  quantities we plug into the action.

			  The f-vector contains the number of
			  simplices of each type contained in the entire
			  spacetime manifold.

			  The b-vector contains the number of simplices
			  of each type contained in each boundary. 

			  We use these because keeping tack of them is much
			  faster during runtime than counting them up after
			  each move. They also make attempting moves much 
			  easier.

			  tracking_vectors.lisp also contains a number of
			  functions that manipulate the f- and b-vectors
			  and the parameters that tell the simulation how 
			  a given move changes the f- and b-vectors.


action.lisp -- This file contains the functions that define the action at 
	       runtime:
			action-exposed - The action without coupling constants
				         plugged in

			build-action - Defines the function "action" by 
				       plugging coupling constants into
				       action-exposed. This is faster than
				       plugging them in every time.

			set-k0-k3-alpha - Sets the coupling constants 
					  k0,k3,k,litL,alpha. k0 and k3 are
					  defined in terms of periodic
					  boundary conditions CDT. We keep
					  them only as a way to compare results
					  between the two types of simulation.

			set-k-litL-alpha - Same as set-k0-k3-alpha, but takes
					   k and litL as input instead of k0
					   and k3.


reset_spacetime.lisp -- This file contains functions that reset the simulation.
		     	One is faster and riskier than the other. Useful for 
			debugging and bulk file operations.


generalized-hash-table-counting-functions.lisp 
	-- This file contains functions that interact with the hash tables
	   that keep track of geometric objects. They are used extensively in 
	   simplex.lisp to count simplices of various types. They're also
	   useful for debugging. They are all meta-functions that take functions
	   as input.


simplex.lisp -- This file contains the functions that build, manipulate, count,
	        and read simplices, the main data structures of the simulation.
		It also contains important parameters and functions for fixed
		boundary conditions. This file is pretty hard to parse and
		contains a lot of low-level functions. For small changes to the
		simulation, you probably don't have to change anything here.
		Makes heavy use of generalized-hash-table-counting-functions.


topological_checks.lisp -- This is a module for the CDT program added by Jonah
			   Miler. It runs a number of tests on a manifold 
			   being simulated to ensure that it is topologically
			   acceptable. Used in initialization.lisp to check
			   the user hasn't put in a topologically unacceptable
			   spacetime. However, these functions are nice 
			   debugging tools as well.


moves.lisp -- The real meat of runtime algorithms live here. This file contains
	      the functions that attempt and perform the ergotic moves on a
	      spacetime during a run of the metropolis algorithm. The moves
	      respect topological restrictions, so they can't change the 
	      2-geometry of the boundary time slices and they can't cause 
	      the spacetime to become topologically unacceptable.


ascii_plotting_tools.lisp -- These functions allow for quick and dirty plotting
			     during runtime. The plots go to the console.
			     Mostly useful for debugging or checking on data
			     remotely if the data is hosted on a computer 
			     that doesn't have X-windows.


initialization.lisp -- This one's a doozy. This file contains all algorithms 
		       used when a simulation starts up. Most functions you
		       call in a script to run a simulation live here.
		       It contains:
		       1) Rajesh Kommu's algorithm for building a minimally 
		          triangulated spacetime with periodic boundary 
			  conditions in time where each spatial slice is
			  homeomorphic to the 2-sphere
		       2) Rajesh Kommu's algorithm for building a minimally 
		          triangulated spacetime with periodic boundary 
			  conditions in time where each spatial slice is
			  homeomorphic to the 2-torus
		       3) David Kamensky's algorithm for changing a minimally
		          triangulated spacetime with periodic boundary
			  conditions, and inserting arbitrary geometries at
			  the boundary, converting to the fixed boundary
			  conditions case. Only works for the 2-sphere
			  topology.
		       4) The algorithm to take a minimally triangulated 
		          spacetime and randomly add volume to it until it is
			  a randomly generated initial spacetime, ready for 
			  the metropolis algorithm.
		       5) The higher-level functions that the user calls to 
		          initialize a spacetime.


montecarlo.lisp -- This file contains the functions for the metropolis 
		   algorithm.


output.lisp -- This file contains functions that take data on the simulation
	       and output to data files. These functions run the algorithms
	       in montecarlo.lisp and then generate various outputs, depending
	       on the user.
;+-----------------------------------------------------------------------------+



MODULES FOR THE LISP SIMULATION
;+-----------------------------------------------------------------------------+
map_phase_space.lisp -- This is a module for the CDT code that can be used to 
		     	mimic the functionality of 
			map_phase_space_parallelized.py. However, it is much
			much slower and less reliable. USE AT YOUR OWN RISK.


parameter_tuning.lisp -- This is a module for the CDT code designed to 
		      	 analytically solve for coupling constants that live
			 on the critical surface of the phase space. Based on
			 Christian Anderson's algorithm. Unfortunately, 
			 fixing the boundaries seems to mess Christian's 
			 algorithm up, and this module currently produces
			 bad results. USE AT YOUR OWN RISK.


tuning_utilities.lisp -- This is a module for the CDT code that is designed
		      	 to interact with map_phase_space_parallelized.py. 
			 The python program calls a number of CDT simulations
			 each with this module added and uses them to take 
			 data on the behavior of the simulation as one varies 
			 coupling constants.


move_tracking.lisp -- This is a module for the CDT code which can track
		      how many moves of a given type are topologically
		      acceptable to attempt on a given time slice. You 
		      can make data files and even movies of move behavior.
		      This module is only useful for debugging purposes.


generate_2_sphere.lisp -- A program written by David Kamensky which generates
		       	  a 2-manifold of arbitrary size and homeomorphic to 
			  the sphere that can be given to the simulation as a
			  boundary. All curvature is concentrated in a few 
			  spots and the algorithm is primitive. For testing
			  only.


quick-test.lisp -- A program written by Rajesh Kommu to test the behavior of
		   the simulation. I have never used it.


test.lisp -- A program written by Rajesh Kommu to test that the simulation
	     doesn't crash. I have never used it.


volume_and_dimension_computations.lisp -- Code written by Rajesh Kommu. I don't
				       	  know what it does or how to use it.
;+-----------------------------------------------------------------------------+
		   

BOUNDARY FILES (contained in ~/boundary_files)
;+-----------------------------------------------------------------------------+
These are all *.boundary files. They are all files that can be given to the
CDT program as boundary conditions for the simulation. Some are extracted from
various other spacetimes using 
data_analysis_scripts/make_boundary_conditions.py
others were written by hand. The ones written by hand are:

tetrahedron.boundary -- a tetrahedron
octahedron.boundary -- an octahedron
icosahedron.boundary -- an icosahedron
;+-----------------------------------------------------------------------------+


SIMULATIONS SCRIPTS (contained in ~/cdt_scripts)
;+-----------------------------------------------------------------------------+
These are all *.script.lisp files. They are templates and files I've
used to run simulations. Use them as templates for your own simulation
files.
;+-----------------------------------------------------------------------------+


C SOURCE CODE (c_data_analysis_code) 
;+-----------------------------------------------------------------------------+
I have no idea what's in here or what it does.
;+-----------------------------------------------------------------------------+
