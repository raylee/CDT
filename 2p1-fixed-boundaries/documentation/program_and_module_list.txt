Program and Module List

Authors: Jonah Miller (jonah.maxwell.miller@gmail.com)
	 Rajesh Kommu
	 Christian Anderson
	 David Kamensky


PYTHON PROGRAMS
average_ensemble.py -- function call: 
		           ./average_ensemble.py /path/to/ensemble/*.3sx2p1

                       takes average number of space-like triangles per time 
		       slice and plots. Fits this to the equation for de Sitter
		       space with a stalk. Error bars are standard deviation
		       of spactial extent, NOT error of fit.



visualize_spacetime.py -- function call: 
		       ./visualize_spacetime.py /path/to/spacetime/file.3sx2p1

		       makes a plot of the spatial extent of a single spacetime
		       as a function of proper time. Dependency of 
		       average_ensemble.py



invert_time.py -- function_call:
			./invert_time.py /path/to/spacetime/file.3sx2p1

			Takes a *.3sx2p1 file and reverses the time coordinate.
			so that a (1,3) simplex with t_low = 0 and t_high = 1
			becomes a (3,1) simplex with t_low = 63 and t_high = 64.
			Useful mostly for debugging.



make_boundary_conditions.py -- function call:
		    ./make_boundary_conditions.py t_low t_high filename.3sx2p1

		    Takes a *.3sx2p1 file and a pair of indices as input. It 
		    generates a pair of text files that can be used by the 
		    fixed boundary code as input for fixed boundaries using the
		    time slices at the chosen indices t_low and t_high 
		    in the simulation that generated filename as the boundaries.



map_phase_space_parallelized.py -- function call: 
			map_phase_space_parallelized.py >> logfilename.log
			
			Runs a simulation over a range of k0 and k3
			values.  The goal is to find at which values
			of k0 and k3 the simulation is stable. Uses a
			module written in lisp for the simulation to
			facilitate taking data on volume change and
			sending it to an output file. The output file
			can be analyzed with k3_of_k0.py and
			visualized with plot_phasemap.py, which are
			described below.

			This approach is different from the one taken
			by Christian in the HL code, where the
			probability of a move being topologically
			acceptable is approximately the same from
			simulation to simulation. Christian solves for
			the coupling constant values that give stable
			volume, whereas I just do a guess and check
			method. The reason is that with fixed
			boundaries, the probability ratios change
			depending on the boundary conditions. Brute
			force was the only completely general method I
			could think of.

			To make the mapping algorithm faster, each
			simulation with set k0 and k3 can be run on a
			seperate CPU. The program takes care of this
			automatically.

			To change simulation parameters, open up te
			file. It should be easy to change which
			boundary files are used, the number of time
			slices, and the target volume. Just change the
			variables in the code. The output is
			*.phasemap.



plot_phasemap.py -- Function call: ./plot_phasemap.py scf filename.phasemap

		    Makes a 3D plot of 3-volume of a CDT simulation as a
         	    function of coupling constants. in
		    2+1 dimensions. Also places the critical surface
		    on the plot for comparison.

		    The input file is a *.phasemap file generated by
		    map_phase_space_parallelized.py

		    Takes two command line arguments: a docstring and
		    a filename.  If the command string contains
		    certain letters, the function does more. Each
		    letter adds a functionality.

		    contains   function does
		    'f'        complete 3D plot of 3-volume(k0,k3)
		    's'        3D plot of 3-volume(k0,k3), but with 
		    	       values 0<=3-volume<=2.
                    'c'        Plots the critical surface and fits k3 as a 
		    	       function of k0. Outputs this information
			       to a file.
 
		    The filename is *.phasemap and is some phasemap.

		    Example calls:
		    ./plot_phasemap.py s T028_V030850.phasemap 
		    ./plot_phasemap.py scf T028_V030850.phasemap 


k3_of_k0.py -- function call: ./k3_of_k0.py file.critical_surface_fit
	       k0 k0' Takes *.critical_surface_fit data generated by
	       plot_phasemap.py (above) and constructs k3 as a
	       function of k0 using it. The function takes any number
	       of inputs. The first input is a fit file and the
	       remaining inputs are each a value of k0. The function
	       returns a value of k3.


