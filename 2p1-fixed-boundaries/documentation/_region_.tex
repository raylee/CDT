\message{ !name(programmers_guide.tex)}
\documentclass[12pt]{article}

\author{Jonah Miller\\
\textit{jonah.maxwell.miller@gmail.com}}
\title{2+1-dimensional Fixed Boundaries CDT: Programmer's Guide}

\usepackage{fullpage}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{color}
%\usepackage{algorithmic}

\begin{document}

\message{ !name(programmers_guide.tex) !offset(-3) }

\maketitle

\section{Introduction}
\label{s:intro}

This is the fixed boundaries branch of Rajesh Kommu's CDT code. The
algorithm was originally worked on by David Kemansky, and later
improved upon and updated by Jonah Miller.

The code implements CDT using an updated action that includes the
boundary terms.

The goal of this file is to explain how to modify the code. I will
first give a very brief overview of the algorithm of the program. Then
dive into data structures and specific functions and how they should
be used. This document assumes the reader knows how to run the
program, its basic structure, and the physics behind it. In order,
these can be found in:
\begin{itemize}
\item The user's guide.
\item The file called program\_and\_module\_list.txt
\item Ambj\o rn and Loll's ``Dynamically Triangulating Lorentzian
  Quantum Gravity,'' the documentation file
  ``Gibbons-Hawkin\_Boundary\_Term\_in\_Causal\_Dynamical\_Triangulations.pdf,''
  and my REU writeup, which is bundled here as well.
\end{itemize}

I also assume the reader knows some basics about programming in
lisp. Here are some of the resources I used:
\begin{itemize}
\item Peter Siebel's ``Practical Common Lisp'' is an excellent,
  readable, and in-depth guide to writing code in lisp. It was my
  primary resource and you can find it online.
  \begin{verbatim}
http://www.gigamonkeys.com/book/
\end{verbatim}
\item The canonical work on Lisp is Paul Graham's ``On Lisp.'' It is available online.
\begin{verbatim}
http://www.paulgraham.com/onlisp.html
\end{verbatim}
\item Successful Lisp is another book available for free online.
\begin{verbatim}
http://psg.com/~dlamkins/sl/contents.html
\end{verbatim}
\item This website links to a number of useful resources.
  \begin{verbatim}
http://www.apl.jhu.edu/~hall/lisp.html
\end{verbatim}
\end{itemize}

Hopefully this guide will help elucidate how to edit the CDT
code-base. If you have any questions, don't hesitate to email me.

\section{The Algorithm}
\label{s:algorithm}
Although I'm sure the reader is familiar with the algorithm of CDT, I
present it here for completeness. The metropolis algorithm as applied
to CDT is as follows:
\begin{enumerate}
\item Generate an arbitrary spacetime constructed of equilateral simplices.
\item Randomly apply one of the ergotic moves to the spacetime.
\item Calculate whether the new spacetime is more or less likely than
  the old spacetime, or less, as given by its un-normalized weight in
  the partition function,\footnote{Technically, the normalized weight
    $\frac{1}{Z}e^{iS}$ is the important quantity. However, since we
    only care about the ratio of weights, the factor of $1/Z$ cancels
    out. This is fortunate, since we don't know what $Z$ is---if we
    did, we could simply perform the path integral.} $e^{i S}$.
\item If the new spacetime is more likely than the previous spacetime,
  accept the change with probability $P=1$. If it is less likely,
  accept the change with probability $P = P(new)/P(old)$. We can
  rewrite this probability as
  $$P = e^{i S_{new} - i S_{old}}.$$
\item Return to step 2, and repeat until the spacetime is acceptably
  probable.
\end{enumerate}
The primary data structures we need to worry about, then, are the
geometric objects. These, and the functions that manipulate them, will
be discussed in section \ref{s:data-structures}. The most important
functions are the action and the ergotic moves. These will be
discussed in some detail in section \ref{s:functions}.

\section{Data Structures}
\label{s:data-structures}

The most important data structures in the simulation are, of course
the goemetric objects that make up the spacetimes. These are points,
edges, triangles, and tetrahedra.

\subsection{Points}
\label{ss:points}

Points are represented as integer identifiers. There is no master list
of points, but, whenever a new point is created, the value of a global
variable is incremented to obtain the next point ID. Points have no
coordinates in this program. In some sense, points are the most
important objects in the simulation. As will be discussed below, the
higher-dimensional simplices are partly defined by which points they
contain. Opbjects that manipulate points are:
\lstset{language=Lisp,frame=shadowbox,rulesepcolor=\color{blue}}
\begin{itemize}
\item \textbf{*LAST-USED-POINT*}---This is the global variable that is
  incremented to obtain point ids. It starts at 0.
\item \textbf{next-pt}---This is a function that increments
  *LAST-USED-POINT* by 1. It then returns the incremented
  *LAST-USED-POINT*. Call it with
\begin{lstlisting}
(next-pt)
\end{lstlisting}
Thus, 
\begin{lstlisting}
(format t "The next point is ~A~%." (next-pt))
\end{lstlisting}
would return 
\begin{verbatim}
The next point is <next point>.
\end{verbatim}
\item \textbf{set-last-used-pt}---In certain circumstances, for
  instance when loading a spacetime from file, we just want to tell
  the simulation how many points IDs have been used, rather than
  increment the global variable. The call
\begin{lstlisting}
(set-last-used-pt point-number)
\end{lstlisting}
will set *LAST-USED-POINT* to point-number.
\end{itemize}

*LAST-USED-POINT* and all objects that manipulate it can be found in ``globals.lisp.''

\subsection{Links/Edges}

\section{Functions}
\label{s:functions}

\end{document}
\message{ !name(programmers_guide.tex) !offset(-153) }
