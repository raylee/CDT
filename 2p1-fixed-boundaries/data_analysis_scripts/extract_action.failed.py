#!/usr/bin/env python2

"""
extract_action.py
Author: Jonah Miller (jonah.maxwell.miller@gmail.com)

This program takes a *.3sx2p1 file and returns the value of the
action. In theory it should work with any version of the CDT code
originally written by Rajesh Kommu on any platform. However, some
changes to the source code are necessary. Primarily, the home
directory of the CDT code will need to be changed. The CDT program
itself must also have a module for calling the action:
action_output.lisp.
"""

# Import statements
#-----------------------------------------------------------------------------
import multiprocessing
import subprocess
import time
import numpy
import sys
import os
import parallel_processing_tools as ppt # A parallel processing
                                        # toolbox written by me

# -----------------------------------------------------------------------------


# Global variables
#-----------------------------------------------------------------------------
# The home directory of the CDT code
cdt_home = '/home/jonah/CDT/2p1-fixed-boundaries/'
# Primary CDT module
cdt_primary = 'cdt2p1.lisp'
# The action-output module for cdt
cdt_action = 'action_output.lisp'
# The command we pass to sbcl:
sbcl_command = '(measure-spacetime-action "{}")'
# The shell subprocess call we use, missing the sbcl command, since it
# changes. The actual sbcl command will be appended.
prog_call = ["nice","sbcl","--dynamic-space-size","2000",
             "--load",cdt_primary,"--load",cdt_action,
             "--eval"]
#-----------------------------------------------------------------------------


# Functions
#-----------------------------------------------------------------------------
def run_sbcl(filenames,prog_call,command):
    """
    Starts num_cores sbcl command processe at a time, but runs the
    sbcl command on every single filename in filenames. Returns a list
    of all outputs generated by the sbcl commands.

    prog_call is a command meant for Popen, but missing an extra
    command at the end. The extra command is command.
    """    
    outputs = [] # The list containing process outputs

    # Each element of partitioned_filenames is a a list of length
    # num_cores of filenames.
    partitioned_filenames = ppt.make_slices(filenames)
    for f_list in partitioned_filenames:
        program_calls =  [prog_call+[command.format(f)] for f in f_list]
        processes = ppt.start_processes(program_calls)
        time.sleep(5)
        ppt.check_processes(processes)
        outputs += [eval(proc.stdout.read()) for proc in processes]

    return outputs

def make_output(sbcl_data,filename):
    """
    Takes the data generated by run_sbcl and a single input *.3sx2p1
    file and generates an output string.
    """
    # Extract some information about the file and make it the header string
    with open(filename,'r') as f:
        header_data = f.readline().rstrip().split()
    headerstring = "Un-normalized probability:\n\t#Slices: {} V: {} BC: {}.\n"
    headerstring = headerstring.format(header_data[2],header_data[3],
                                       header_data[0])
    # Make a date string
    datestring = time.ctime() + '\n'
    # The string with useful output
    mean = numpy.mean(sbcl_data)
    std_dev = numpy.std(sbcl_data)
    outstring = "Mean: {}, Standard Deviation: {}.\n".format(mean,std_dev)

    return headerstring + datestring + outstring

def main(filenames):
    """
    Takes any number of filenames as input and returns the average and
    standard deviation of the un-normalized probability of a
    spacetime. The return is to stdout.
    """
    # Generate the data, num_cores at a time.
    sbcl_data = run_sbcl(filenames,prog_call,sbcl_command)
    # Generate an output string 
    outstring = make_output(sbcl_data,filenames[0])
    return outstring
#-----------------------------------------------------------------------------


# Main loop
if __name__ == "__main__":
    print "Generating the average and standard deviation"
    print "of the un-normalized probability of the spacetime ensemble."
    print "Please wait.\n...\n...\n"

    pwd = os.getcwd() # Get the current directory of the file 
    fnames = [pwd+'/'+f for f in sys.argv[1:]] # Generate a list of
                                               # full filepaths
    os.chdir(cdt_home) # Change directories to the CDT directory
    outstring = main(fnames) # Do the data analysis
    os.chdir(pwd) # Go back to original directory
    print outstring # Return output
