sphere_generator/documentation/programmers_guide.txt

Time-stamp: <2012-10-21 16:36:46 (jonah)>

Author: Jonah Miller (jonah.maxwell.miller@gmail.com)


This is the programmer's guide for sphere_generator, a program written
in python that generates geometries homeomorphic to the 2-sphere for
use with CDT/2p1-fixed-boundaries as boundary geometries in
2+1-dimensional Causal Dynamical Triangulations. This guide assumes
you know how to write in Python (python 2.7 specifically) and that you
have read the user's guide.

The goal of this guide is to give you a basic overview of the
program's behaviour so that you can edit the code successfully. The
program is hopefully well-documented, and Python is extremely
readable, so implimentation details are not discussed in great
detail. A good way to use this guide might be to skim it once. Then,
when you run intoa method or class call you don't recognize, open this
file and search for the method name.

If you can't figure something out, try loading the program in the
python interpreter and playing around. The file top_level_wrapper.py
exists for this reason. It loads all modules and does nothing
else. The help and dir calls on classes, objects, and modules should
be helpful.

sphere_generator uses Monte Carlo methods to generate spheres. The
reason we use Monte Carlo is because you can only perfectly
triangulate a sphere out of equilateral triangles in the case of 4
triangles, 8 triangles, or 20 triangles. We want to get as close to a
perfect sphere as possible, so we randomly generate spheres, and
select for the qualities we want: low standard deviation of curvature
and the correct surface area (number of triangles). The way we
randomly generate a sphere is we construct an object out of
triangles. We then apply one of 3 ergodic moves, which locally change
the sphere and, when composed in the right way, can change any sphere
into any other sphere.

If you have any questions, feel free to contact me.

sphere_generator has several parts:
--------------------------------------------------------------------------
utilities.py  --- This file contains generally useful functions that aren't
                  specific to sphere_generator. For example, functions that
		  operate on collections of sets are found here.

error_checking.py --- This file contains some small methods used for
  		      debugging. Just small snippets of code we use
  		      over and over again.

simplex_ancestors.py --- This file contains the ancestor class for
 		         geometric objects, called geometry. The class
 		         contains methods for book-keeping of
 		         geometric objects:
			 -- generating object ids (unique numbers specifying
			     a geometric object)
			 -- adding objects to their respective collections
			 -- deleting objects and reclaiming their ids
			 -- counting objects
			 -- a method that takes an object id or an object
			    instance and always returns the instance
			    (or raises an error).

simplex_descendants.py -- This file contains the classes for geometric
		          objects that inherit the methods from the
		          geometry class. These are the primary data
		          structures of the simulation. The classes
		          are:
			  -- vertex. This class keeps track of points
			      (vertices of triangles).
			  -- edge. This class keeps track of edges of
			      triangles.
			  -- triangle. This class keeps track of equilateral
			      triangles.
			  Each class has at least 3 static/global variables:
			  -- last_used_id = the largest id number for
			      objects of that type.
			  -- recycled_ids = set of ids that have been used
			      but are not currently in use.
			  -- instances = a dictionary of object instances.
			      The value is an object/class instance, the key
			      is the ID associated with that object.
			  Each object type does different things and
			  keeps track of other object types. The
			  curvature around a given vertex is related
			  to the number of triangles connected to that
			  vertex. Triangles keep track of their
			  neighbors for conveneince. Neighbors of of
			  triangles and triangles connected to
			  vertices need to be set periodically during
			  the simulation.

state_manipulation.py -- This file contains functions which manipulate
		         the data structures defined in simplex_*.py
		         at a higher level. These are all for
		         convenience only but they make things much
		         more sane. Most importantly, the build_* and
		         remove_* methods in the module make geometric
		         objects but theck to make sure those objects
		         don't exist yet.  They also ensure to build
		         sub-simplices if necessary.  new
		         points/vertices are always generated by hand,
		         but the methods in state_manipulation that
		         build triangles will also build the edges
		         required if they don't exist yet. All
		         geometric objects are removed by hand.

initialization.py -- This file contains the methods required to build
		     a sphere at the start of a simulation. It can
		     load a sphere from a file or build a sphere from
		     scratch. If it builds the sphere from scratch, it
		     first builds a tetrahedron (calculated by hand),
		     which is the minimal triangulation of a sphere,
		     and then performs surface area-increasing moves
		     until the sphere is the appropriate surface
		     area. More on moves below.

state_tracking.py -- This file contains classes and methods for measuring
		      properties of a generated sphere. It also contains
		      classes used to predict what a sphere will look like
		      after a given ergotic move.
		     -- sphere = A class that keeps track of the current
		                 state of a sphere. Can check:
				 -- total curvature (depends only on surface
				     area. Good for error checking.)
				 -- Euler characteristic (should be 2 no
				     matter what. Good for error checking.)
				 -- standard deviation of curvature
				 -- surface area
				 -- vertex, triangle, and edge objects
				     currently in use.
		 	 Printing a sphere instance gives a quick summary of
			 the current state of the simulation.
		     -- imaginary_vertex = a class used for predicting
		                           how a given ergotic move
		                           will affect the
		                           simulation. If it's
		                           volume-increasing, it adds
		                           to the sum of curvature
		                           standard deviation. If its
		                           volume-decreasing, it
		                           subtracts.  Has some number
		                           of "triangles" attached to
		                           it that are set just by
		                           giving a number during
		                           initialization.
 		     -- vertex_count = a class that keeps track of the
		     	               number of vertices of each order, as
				       a function of order. Order is the
				       number of triangles attached to each
				       vertex. Sublcasses of the vertex_count
				       class allow you to select for
				       criteria relating to vertex order.
		     -- move_data = a class that contains many
		                    instances of the imaginary_vertex
		                    class. It has methods to predict
		                    mean curvature and standard
		                    deviation based on the imaginary
		                    vertices given to it. Only give a
		                    move_data instance
		                    imaginary_vertices that are
		                    related to a move you're
		                    checking. volume-decreasing
		                    imaginary vertices are vertices
		                    that you're deleting or changing
		                    as they are before the move.
		                    Volume-increasing vertices are
		                    vertices that you're adding or
		                    changing, as they are after the
		                    move.  move_data also keeps track
		                    of the complex of triangles being
		                    changed by a move, the function
		                    that performs the move, and the
		                    change in surface area that the
		                    move induces in the sphere, where
		                    the latter three are passed to the
		                    constructor. move_data instances are
				    the return values of try_move functions.
		     state_tracking also contains some methods for looking
		     at local properties of a given sphere:
		     -- find_opposite_vertices looks for a pair of
                         vertices in a set of triangles that don't
                         share a triangle. Returns all such vertices.
		     -- shared_triangles_in_complex: given a pair of vertices,
		         this method finds out if they are both vertices
			 of the same triangle in a complex.
		     -- find_opposite_vertices_in_complex is like
		         find_opposite_vertices, but the vertices just don't
			 share a triangle in the complex, not in the whole
			 sphere.

moves.py --- This file contains functions relating to the ergodic moves
	     in the simulation.
	     -- It contains the class complex, which encapsulates a
	         set of triangles a move operates on, and any other
	         important information a move needs to complete its
	         task.  This is a sort of modular class. It contains
	         anything you need it to contain, which is why it has
	         descendents for specific moves.
	     -- There are three types of function for each ergodic move.
	        -- The complex_* function, given a triangle (or id),
		    generates the complex of triangles around it which a
		    move needs to operate on. Some moves are topologically
		    unacceptable unless certain conditions are met. If
		    the conditions can't be met, the function returns false.
		    If more than one complex is topologically acceptable,
		    the complex_* function returns one at random.
		-- The try_* function calls complex_* for the correct
		    move and then predicts what will happen if the move is
		    performed, calling the move_data class (as discussed
		    above). If complex_* returns false, so does try_*.
		    try_* returns a move_data class instance with all the
		    information necessary to decide whether or not to
		    perform a move and, if necessary, perform it.
		-- The move_* function actually performs a given move. It
		    takes a complex as input.
	     There are 3 types of move.
	     -- The 1->3 move takes 1 traingle and splits it into 3 by
	         adding a vertex in the center.
	     -- The 3->1 move inverts the 1->3 move and undoes it.
	     -- The 2->2 move rotates a pair of triangles by 90 degrees.
	         It is its own inverse.

monte_carlo.py --- This file contains all you need to perform the Metropolis
	           algorithm for Monte Carlo simulations. The algorithm is
		   set up as a class instance, so that more algorithms can
		   be added if necessary. The ancestor class, metropolis,
		   contains methods likely necessary no matter the algorithm
		   used. The descendant classes are:
		   -- select_for_area is a metropolis algorithm that only
		      selects for the surface area of the sphere.
		   -- select_for_curvature is a metropolis algorithm that
		      specifically selects for standard deviation of
		      curvature.

output.py --- This file contains all the methods necessary to run a
	      Monte Carlo simulation and save the simulated sphere to
	      a file. There are a bunch of methods for saving a sphere
	      to a file and there's also two methods for gathering
	      data. Each takes a metropolis class instance, an initial
	      sweep number, a final sweep number, a value for damping
	      on the number of vertices of order 5, a value for
	      damping on the number of vertices of order 6, and a
	      command for how often to save. It then gathers data
	      until some stopping condition is met.
	      -- gather_data_to_1_file saves the sphere every
	      	 save_every_n_sweeps to 1 file and gathers data
	      	 for final_sweep-initial_sweep sweeps.
	      -- gather_data_to_n_files saves to a new file every
	         save_every_n_sweeps and gathers data for
		 final_sweep-initial_sweep sweeps.
	      -- stop_at_microscopically_optimal saves to 1 file every
	      	 save_every_n_sweeps and stops when the sphere is close
		 enough to  microscopically optimal (see the documentation).
	      -- save_many_microscopically_optimal performs
	      	 final_sweep-initial_sweep sweeps. It only saves a file when
		 the sphere meets the conditions for close enough to
		 microscopically optimal.

sphere_generator.py --- This is the UI for the whole program. You call it
		        by command line to run the program.
		        
top_level_wrapper.py --- A tool for debugging. Loads every module and does
		         nothing else.

--------------------------------------------------------------------------

Happy hacking!
